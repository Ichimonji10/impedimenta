Programmer-created functions are prototype functions. Prototype functions can be declared, used, and defined by the user. Prototype functions were introduced in ANSI C
Prototype functions are used in three different contexts in a program
Firstly, prototype fuctions are typically declared. The declaration and definition can be combined, but this is not necessary (nor always good form).
A declaration is in the general form 'type name(arguments);' For example, one might say int square(int seed);
The type tells the compiler what the function will return, if anything (can use void). The name is simply what name is used when identifying the fuction.
Arguments tell what, if any, values are passed to the function for use.
In sum, prototype functions can be referenced in three ways:
	a function prototype tells the compiler what type of function is coming and how to treat it,
	a function call causes the program to jump to that function (and adjust the stack accordingly),
	a function definition, well, defines the prototype function.
Variables used in called functions are constructed from two pieces of data: a formal parameter, and an actual argument.
	Formal parameters are defined inside the parentheses of a function header. A formal parameter declares a variable of a certain type for use within a function.
	Actual arguments are defined inside the parentheses of a function call. An actual argument is an expression which evaluates to a value.
Actual arguments evaluate to a value which is assigned to the variable declared by a formal parameter.
return; should be used in a type void function.
void function(void); is valid

There are at least two different types of files that can be used when compiling a program, but only one of those two types of files are actually used for compilation.
The two types of files used when compiling a program are source code files and header files.
Any file ending with a .c extension is considered a source code file.
When compiling a program, make sure to include all of the .c files. The .c files define the program logic, variables, constants, and such.
(dot)c files also define which header files should be included.
Header files also define functions and constants used in source code files.
The difference is, header files do not define the logic of a program; they ONLY define functions and constants.
It is good programming practice to include the main() function in one .c file, all other functions in another .c file(s), and constants used in a header file.
Make sure to include a #include statement for your header files in your source code.
For example, both your prog1.c and func.c files would include the statements #include <stdio.h> and #include <options.h>

If a function is called and tries to modify a variable in its parent function without returning a value, the & must be used.
The only way to pass data from a called function to its parent function without using the return; statement is to use pointers.
The & points to the address of a value, rather than the value itself.
Pointers are a type of variable used to hold data that represents and address, rather than holding data that represents an integer, character or something else.
Different types of variables, constants, and such are kept track of using different kinds of data.
For example, not only would there be data saying that a particular location in memory is an int, there would also be data storing the address itself, perhaps what function it belongs to, and maybe other data too.
This is why, when assigning a value to a pointer, the pointer must point to the correct data type.
If a pointer is declared as an int, then the pointer can only hold the address of an int.
Similarly, if a pointer is declared as a char, the pointer can hold only the address of a char.
The statements ptr = &bah; and var = *ptr; amount to val = bah;
In other words, the statement abolve states that "variable is equal to the value stored at the address stored in pointer".
There are some special pointers. For example, the pointer type FILE holds information about an accessed file, and points to a certain location in that file.
When using the * dereferencing operator to print out the value of a location in memory, use the %p conversion specifier modifier.
-Think "variable is equal to data stored at address of x"
-A regular variable makes the value the default quantity and the address a derived quantity, using the & operator.
-A pointer variable makes the address the default quantity and the value a derived quantity, using the * operator.
