notes.txt -- Jeremy Audet, started Fri Oct 23 10:40:55 EDT 2009

when declaring a pointer, make sure to use an asterisk. For example, use int* pPointer;. The * tells you that what you're declaring is a pointer.
Pointers can store any value that their type can store, but they're typically used to store memory addresses, or the address of a memory location.
For example, I can set a pointer equal to the memory address holding value i by stating pPointer = &i.

The only exception to this rule is when declaring a pointer in a function header. For example, if I 

***Declaring & Initializing Arrays***
array[] = {comma separated list}; automatically sets the array size to however many values are in the comma-separated list
array[CONST] = {comma separated list}; sets the array size to CONST, no matter how many values are in the braces
If CONST is a larger value than the number of values in the list, and at least one value is in the list, the rest of the values will be set to zero. For example, the statement: 

	array[5] = {0, 1, 2};

would make the values 0, 1, 2, 0, and 0. 
If no values were placed in the list, the compiler would not place zeroes for values in the list. Rather, whatever is in memory would be placed in the array. It is also possible to initialize particular elements of an array. For example, the statement: 

	array[6] = {[4] = 123, 32}; 

is valid.
Note the 32 following the 4th element. This means that the sixth (numbered array[5]) element is initialized to 32. Also, because at least one element of the array has been initialized, all uninitialized elements are set to 0. Declaring an array means you are doing two things: setting aside memory to hold data, and declaring a pointer with a certain name. For example, the statement:

	char array[10]; 

sets aside 10 sequential chunks of memory, each large enough to hold a char. The statement ALSO creates a pointer, of type char, called array.


***More Arrays***
Assuming a one-level array:
ptr == &ptr[0]
ptr + 1 == &ptr[1]
*(ptr + 1) == ptr[1]

I consider a one-level array to be something like this: int rates[10];
I consider a zero-level array to be something like this: int rates;
Note that a zero-level array is simply an int. An int is one of the fundamental types. All arrays are derived types, in that they make a type out of fundamental types. You cannot make an array without using, at some level, a fundamental types. Fundamental types are almost like the vowels of the C language.

***const and Pointers***
The keyword const can be used in a pointer declaraion. Where the keyword is placed greatly affects how the pointer behaves.
Take a look at the following function prototypes:

	void show_array(const double ar[], int n);
	void mult_array(double ar[], int n, double mult);

Both prototypes include the statement "double ar[]". This statement is the same as "double * ar". The prototypes are really declaring pointers; the array notation can be used to make it clearer that the pointers will be pointing to arrays. The prototypes declare a pointer, called ar, of type double. In other words, 

	double ar[] == double * ar

When calling the first function, a statement such as "show_array(balances, SIZE);" will be used.
When calling the second function, a statement such as "mult_array(balances, SIZE, 2.4);" will be used.
Note that both functions can be used in the same program, and "balances" does not need to be a constant array.
Because of the keyword const in the first prototype, show_array will treat balances as if it is a constant. However, the value of ar itself is NOT constant.

Consider these four declarations:
double * pData;
const double * pData;
double * const pData;
const double * const pData;
The first makes a pointer which can both change what address is held, and can change what data is held at that address.
The second makes a pointer which can change what address it holds, but cannot change what data is held at that address.
The third makes a pointer chich can not change what address it holds, but can change what data is held at that address.
The foruth makes a pointer chich can not cange what address it holds, nor can change what data is held at that address.
In sum, the first const keyword protects what the pointer points to, while the second const keyword protects the value of the pointer itself.

***notes of sizeof()***
sizeof() returns the size of its argument, in bytes.
The argument to sizeof() can be either a variable, a pointer, or an array.
If the argument to sizeof() is an array, sizeof() can return the size of either the pointer to the first element of the array, or the size of the entire array.
I'm not sure why. Frrrrick.

***pointers & arrays***
A pointer-to-constant is a pointer which is declared as being constant. The pointer-to-constant must treat the data it points to as being constant, even if that data is not declared as constant. The actual data at the address held may or may not be constant, and can be changed with mechanisms other than using a pointer-to-constant.

An array name is just a label. It is a label which is converted into a constant pointer, addressed to the first element of that array, at compile time.
Note that if you declared a pointer (char * ptr;), the pointer is a variable, not a constant variable. Therefore, it is legal to change the value of a pointer variable.
It is legal to change the contents of an array.
It is not legal to change the value of an array label. This is equivalent to saying that: it is not legal to change the value of a constant pointer to the first element of an array.
Remember: An array passed to a function (either user defined, or library defined) is converted to a constant pointer to the first element of that array.

sizeof() is a very special function. It does not automatically convert an array label into a pointer to the first element of that array. Rather, it finds the size of the entire array. So sizeof(array) might return a value of 20, if array consists of characters. In order for sizeof() to return the size, in bytes, of an entire array, it must have access to the contents of the entire array.
Assume that an array label is used as an argument when calling a function. The function declaration might be something like this: void foo(char arr_arg[], char * ptr_arg); Inside the function, two sizeof() calls are made; one is sizeof(arr_arg);, and the other is sizeof(ptr_arg);. Both calls to sizeof() would, in this case, return a value of 8 (on my 64 bit machine). The calls to sizeof() would NOT return the size, in bytes, of the entire array. This is because sizeof() only has access to a pointer, rather than an entire array.

These statements are equivalent:
pBook[5];
*(pBook + 5);
They are equivalent if pBook is either a pointer or an array identifier.

***how to read a declaration***
int pants;
int * pants;
int pants[20];
int * pants[20];
int pants[20][5];
int ** pants;
int (* pants)[2];
